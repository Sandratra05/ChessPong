<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/chesspong/controller/CollisionHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/chesspong/controller/CollisionHandler.java" />
              <option name="originalContent" value="package com.chesspong.controller;&#10;&#10;import com.chesspong.model.Ball;&#10;import com.chesspong.model.Board;&#10;import com.chesspong.model.Piece;&#10;import com.chesspong.model.PongPaddle;&#10;&#10;public class CollisionHandler {&#10;    public void handleBallCollisions(Ball ball, Board board, PongPaddle paddle1, PongPaddle paddle2) {&#10;        // Collision with paddles&#10;        if (ball.getY() - ball.getRadius() &lt;= paddle1.getY() + paddle1.getHeight() &amp;&amp;&#10;            ball.getY() + ball.getRadius() &gt;= paddle1.getY() &amp;&amp;&#10;            ball.getX() &gt;= paddle1.getX() &amp;&amp; ball.getX() &lt;= paddle1.getX() + paddle1.getWidth()) {&#10;            ball.setVy(-ball.getVy());&#10;        }&#10;        if (ball.getY() + ball.getRadius() &gt;= paddle2.getY() &amp;&amp;&#10;            ball.getY() - ball.getRadius() &lt;= paddle2.getY() + paddle2.getHeight() &amp;&amp;&#10;            ball.getX() &gt;= paddle2.getX() &amp;&amp; ball.getX() &lt;= paddle2.getX() + paddle2.getWidth()) {&#10;            ball.setVy(-ball.getVy());&#10;        }&#10;&#10;        // Collision with pieces&#10;        // Compute visible board screen origin and start column so we can map piece (col,row) -&gt; screen coords&#10;        int start = (8 - board.getNumFiles()) / 2;&#10;        double boardScreenLeft = 400.0 - (board.getNumFiles() * 50) / 2.0; // same centering used in GameController&#10;        double boardOffsetY = 100.0;&#10;&#10;        double prevX = ball.getPrevX();&#10;        double prevY = ball.getPrevY();&#10;        double curX = ball.getX();&#10;        double curY = ball.getY();&#10;&#10;        for (Piece piece : board.getAllPieces()) {&#10;            if (!piece.isAlive()) continue;&#10;&#10;            // If piece column is outside visible range, skip&#10;            int col = piece.getX();&#10;            if (col &lt; start || col &gt;= start + board.getNumFiles()) continue;&#10;&#10;            double px = boardScreenLeft + (col - start) * 50.0;&#10;            double py = boardOffsetY + piece.getY() * 50.0;&#10;            double pw = 50.0;&#10;            double ph = 50.0;&#10;&#10;            // fast reject by segment AABB&#10;            double segMinX = Math.min(prevX, curX) - ball.getRadius();&#10;            double segMaxX = Math.max(prevX, curX) + ball.getRadius();&#10;            double segMinY = Math.min(prevY, curY) - ball.getRadius();&#10;            double segMaxY = Math.max(prevY, curY) + ball.getRadius();&#10;            if (segMaxX &lt; px || segMinX &gt; px + pw || segMaxY &lt; py || segMinY &gt; py + ph) {&#10;                continue;&#10;            }&#10;&#10;            // expanded rect to account for radius (swept circle approx)&#10;            double expandedPx = px - ball.getRadius();&#10;            double expandedPy = py - ball.getRadius();&#10;            double expandedPw = pw + 2 * ball.getRadius();&#10;            double expandedPh = ph + 2 * ball.getRadius();&#10;&#10;            boolean hitDuringMove = segmentIntersectsAABB(prevX, prevY, curX, curY, expandedPx, expandedPy, expandedPw, expandedPh);&#10;            boolean overlapNow = circleIntersectsAABB(curX, curY, ball.getRadius(), px, py, pw, ph);&#10;&#10;            if (!hitDuringMove &amp;&amp; !overlapNow) {&#10;                continue;&#10;            }&#10;&#10;            // collision occurred&#10;            System.out.println(&quot;Collision with piece at (&quot; + piece.getX() + &quot;, &quot; + piece.getY() + &quot;)&quot;);&#10;&#10;            // decrease life and possibly remove&#10;            piece.setHealth(piece.getHealth() - 1);&#10;            System.out.println(&quot;Piece health: &quot; + piece.getHealth());&#10;            boolean stillAlive = piece.isAlive();&#10;            if (!stillAlive) {&#10;                board.removePiece(piece.getX(), piece.getY());&#10;            }&#10;&#10;            // Reflect the ball in all cases (even if piece died this hit)&#10;            // determine closest point on rect to current center&#10;            double closestX = clamp(curX, px, px + pw);&#10;            double closestY = clamp(curY, py, py + ph);&#10;            double dx = curX - closestX;&#10;            double dy = curY - closestY;&#10;&#10;            // If exactly centered on edge (rare) fall back to prev-based decision&#10;            if (Math.abs(dx) &lt; 1e-6 &amp;&amp; Math.abs(dy) &lt; 1e-6) {&#10;                double centerX = px + pw / 2.0;&#10;                double centerY = py + ph / 2.0;&#10;                double toPrevX = prevX - centerX;&#10;                double toPrevY = prevY - centerY;&#10;&#10;                if (Math.abs(toPrevX) &gt; Math.abs(toPrevY)) {&#10;                    // horizontal impact&#10;                    if (toPrevX &lt; 0) ball.setX(px - ball.getRadius() - 0.1);&#10;                    else ball.setX(px + pw + ball.getRadius() + 0.1);&#10;                    ball.setVx(-ball.getVx());&#10;                } else {&#10;                    if (toPrevY &lt; 0) ball.setY(py - ball.getRadius() - 0.1);&#10;                    else ball.setY(py + ph + ball.getRadius() + 0.1);&#10;                    ball.setVy(-ball.getVy());&#10;                }&#10;            } else {&#10;                // reflect on the axis of larger penetration direction&#10;                if (Math.abs(dx) &gt; Math.abs(dy)) {&#10;                    // reflect horizontal&#10;                    if (dx &lt; 0) ball.setX(closestX - ball.getRadius() - 0.1);&#10;                    else ball.setX(closestX + ball.getRadius() + 0.1);&#10;                    ball.setVx(-ball.getVx());&#10;                } else {&#10;                    // reflect vertical&#10;                    if (dy &lt; 0) ball.setY(closestY - ball.getRadius() - 0.1);&#10;                    else ball.setY(closestY + ball.getRadius() + 0.1);&#10;                    ball.setVy(-ball.getVy());&#10;                }&#10;            }&#10;&#10;            // handle only one piece per frame to avoid double collisions&#10;            break;&#10;        }&#10;&#10;        // Wall bounces (board boundaries) - visible board bounds&#10;        double left = 400.0 - (board.getNumFiles() * 50) / 2.0;&#10;        double right = left + board.getNumFiles() * 50.0;&#10;        if (ball.getX() - ball.getRadius() &lt;= left || ball.getX() + ball.getRadius() &gt;= right) {&#10;            ball.setVx(-ball.getVx());&#10;        }&#10;        if (ball.getY() - ball.getRadius() &lt;= 100.0 || ball.getY() + ball.getRadius() &gt;= 500.0) {&#10;            ball.setVy(-ball.getVy());&#10;        }&#10;    }&#10;&#10;    // Liang-Barsky clipping to test segment vs AABB&#10;    private boolean segmentIntersectsAABB(double x1, double y1, double x2, double y2, double rx, double ry, double rw, double rh) {&#10;        double t0 = 0.0, t1 = 1.0;&#10;        double dx = x2 - x1;&#10;        double dy = y2 - y1;&#10;        double[] p = {-dx, dx, -dy, dy};&#10;        double[] q = {x1 - rx, rx + rw - x1, y1 - ry, ry + rh - y1};&#10;&#10;        for (int i = 0; i &lt; 4; i++) {&#10;            double pi = p[i];&#10;            double qi = q[i];&#10;            if (pi == 0) {&#10;                if (qi &lt; 0) return false;&#10;            } else {&#10;                double t = qi / pi;&#10;                if (pi &lt; 0) {&#10;                    if (t &gt; t1) return false;&#10;                    if (t &gt; t0) t0 = t;&#10;                } else {&#10;                    if (t &lt; t0) return false;&#10;                    if (t &lt; t1) t1 = t;&#10;                }&#10;            }&#10;        }&#10;        return t0 &lt;= t1;&#10;    }&#10;&#10;    private boolean circleIntersectsAABB(double cx, double cy, double r, double rx, double ry, double rw, double rh) {&#10;        double closestX = clamp(cx, rx, rx + rw);&#10;        double closestY = clamp(cy, ry, ry + rh);&#10;        double dx = cx - closestX;&#10;        double dy = cy - closestY;&#10;        return dx * dx + dy * dy &lt;= r * r;&#10;    }&#10;&#10;    private double clamp(double v, double a, double b) {&#10;        if (v &lt; a) return a;&#10;        if (v &gt; b) return b;&#10;        return v;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chesspong.controller;&#10;&#10;import com.chesspong.model.Ball;&#10;import com.chesspong.model.Board;&#10;import com.chesspong.model.Piece;&#10;import com.chesspong.model.PongPaddle;&#10;&#10;public class CollisionHandler {&#10;    public void handleBallCollisions(Ball ball, Board board, PongPaddle paddle1, PongPaddle paddle2) {&#10;        double prevX = ball.getPrevX();&#10;        double prevY = ball.getPrevY();&#10;        double curX = ball.getX();&#10;        double curY = ball.getY();&#10;&#10;        // Handle paddle collisions using the robust resolver; stop after first handled&#10;        if (resolvePaddleCollision(ball, paddle1, prevX, prevY, curX, curY)) return;&#10;        if (resolvePaddleCollision(ball, paddle2, prevX, prevY, curX, curY)) return;&#10;&#10;        // Collision with pieces&#10;        int start = (8 - board.getNumFiles()) / 2;&#10;        double boardScreenLeft = 400.0 - (board.getNumFiles() * 50) / 2.0; // same centering used in GameController&#10;        double boardOffsetY = 100.0;&#10;&#10;        for (Piece piece : board.getAllPieces()) {&#10;            if (!piece.isAlive()) continue;&#10;&#10;            int col = piece.getX();&#10;            if (col &lt; start || col &gt;= start + board.getNumFiles()) continue;&#10;&#10;            double px = boardScreenLeft + (col - start) * 50.0;&#10;            double py = boardOffsetY + piece.getY() * 50.0;&#10;            double pw = 50.0;&#10;            double ph = 50.0;&#10;&#10;            double segMinX = Math.min(prevX, curX) - ball.getRadius();&#10;            double segMaxX = Math.max(prevX, curX) + ball.getRadius();&#10;            double segMinY = Math.min(prevY, curY) - ball.getRadius();&#10;            double segMaxY = Math.max(prevY, curY) + ball.getRadius();&#10;            if (segMaxX &lt; px || segMinX &gt; px + pw || segMaxY &lt; py || segMinY &gt; py + ph) {&#10;                continue;&#10;            }&#10;&#10;            double expandedPx = px - ball.getRadius();&#10;            double expandedPy = py - ball.getRadius();&#10;            double expandedPw = pw + 2 * ball.getRadius();&#10;            double expandedPh = ph + 2 * ball.getRadius();&#10;&#10;            boolean hitDuringMove = segmentIntersectsAABB(prevX, prevY, curX, curY, expandedPx, expandedPy, expandedPw, expandedPh);&#10;            boolean overlapNow = circleIntersectsAABB(curX, curY, ball.getRadius(), px, py, pw, ph);&#10;&#10;            if (!hitDuringMove &amp;&amp; !overlapNow) {&#10;                continue;&#10;            }&#10;&#10;            System.out.println(&quot;Collision with piece at (&quot; + piece.getX() + &quot;, &quot; + piece.getY() + &quot;)&quot;);&#10;&#10;            piece.setHealth(piece.getHealth() - 1);&#10;            System.out.println(&quot;Piece health: &quot; + piece.getHealth());&#10;            boolean stillAlive = piece.isAlive();&#10;            if (!stillAlive) {&#10;                board.removePiece(piece.getX(), piece.getY());&#10;            }&#10;&#10;            double closestX = clamp(curX, px, px + pw);&#10;            double closestY = clamp(curY, py, py + ph);&#10;            double dx = curX - closestX;&#10;            double dy = curY - closestY;&#10;&#10;            if (Math.abs(dx) &lt; 1e-6 &amp;&amp; Math.abs(dy) &lt; 1e-6) {&#10;                double centerX = px + pw / 2.0;&#10;                double centerY = py + ph / 2.0;&#10;                double toPrevX = prevX - centerX;&#10;                double toPrevY = prevY - centerY;&#10;&#10;                if (Math.abs(toPrevX) &gt; Math.abs(toPrevY)) {&#10;                    if (toPrevX &lt; 0) ball.setX(px - ball.getRadius() - 0.1);&#10;                    else ball.setX(px + pw + ball.getRadius() + 0.1);&#10;                    ball.setVx(-ball.getVx());&#10;                } else {&#10;                    if (toPrevY &lt; 0) ball.setY(py - ball.getRadius() - 0.1);&#10;                    else ball.setY(py + ph + ball.getRadius() + 0.1);&#10;                    ball.setVy(-ball.getVy());&#10;                }&#10;            } else {&#10;                if (Math.abs(dx) &gt; Math.abs(dy)) {&#10;                    if (dx &lt; 0) ball.setX(closestX - ball.getRadius() - 0.1);&#10;                    else ball.setX(closestX + ball.getRadius() + 0.1);&#10;                    ball.setVx(-ball.getVx());&#10;                } else {&#10;                    if (dy &lt; 0) ball.setY(closestY - ball.getRadius() - 0.1);&#10;                    else ball.setY(closestY + ball.getRadius() + 0.1);&#10;                    ball.setVy(-ball.getVy());&#10;                }&#10;            }&#10;&#10;            break;&#10;        }&#10;&#10;        // Wall bounces (board boundaries) - visible board bounds&#10;        double left = 400.0 - (board.getNumFiles() * 50) / 2.0;&#10;        double right = left + board.getNumFiles() * 50.0;&#10;        if (ball.getX() - ball.getRadius() &lt;= left || ball.getX() + ball.getRadius() &gt;= right) {&#10;            ball.setVx(-ball.getVx());&#10;        }&#10;        if (ball.getY() - ball.getRadius() &lt;= 100.0 || ball.getY() + ball.getRadius() &gt;= 500.0) {&#10;            ball.setVy(-ball.getVy());&#10;        }&#10;    }&#10;&#10;    // resolve paddle collision; returns true if a collision was handled&#10;    private boolean resolvePaddleCollision(Ball ball, PongPaddle paddle, double prevX, double prevY, double curX, double curY) {&#10;        double px = paddle.getX();&#10;        double py = paddle.getY();&#10;        double pw = paddle.getWidth();&#10;        double ph = paddle.getHeight();&#10;&#10;        double segMinX = Math.min(prevX, curX) - ball.getRadius();&#10;        double segMaxX = Math.max(prevX, curX) + ball.getRadius();&#10;        double segMinY = Math.min(prevY, curY) - ball.getRadius();&#10;        double segMaxY = Math.max(prevY, curY) + ball.getRadius();&#10;        if (segMaxX &lt; px || segMinX &gt; px + pw || segMaxY &lt; py || segMinY &gt; py + ph) {&#10;            return false;&#10;        }&#10;&#10;        double expandedPx = px - ball.getRadius();&#10;        double expandedPy = py - ball.getRadius();&#10;        double expandedPw = pw + 2 * ball.getRadius();&#10;        double expandedPh = ph + 2 * ball.getRadius();&#10;&#10;        boolean hitDuringMove = segmentIntersectsAABB(prevX, prevY, curX, curY, expandedPx, expandedPy, expandedPw, expandedPh);&#10;        boolean overlapNow = circleIntersectsAABB(curX, curY, ball.getRadius(), px, py, pw, ph);&#10;        if (!hitDuringMove &amp;&amp; !overlapNow) return false;&#10;&#10;        double closestX = clamp(curX, px, px + pw);&#10;        double closestY = clamp(curY, py, py + ph);&#10;        double dx = curX - closestX;&#10;        double dy = curY - closestY;&#10;&#10;        if (Math.abs(dx) &lt; 1e-6 &amp;&amp; Math.abs(dy) &lt; 1e-6) {&#10;            double centerX = px + pw / 2.0;&#10;            double centerY = py + ph / 2.0;&#10;            double toPrevX = prevX - centerX;&#10;            double toPrevY = prevY - centerY;&#10;&#10;            if (Math.abs(toPrevX) &gt; Math.abs(toPrevY)) {&#10;                // horizontal impact&#10;                if (toPrevX &lt; 0) {&#10;                    ball.setX(px - ball.getRadius() - 0.1);&#10;                    ball.setVx(-Math.abs(ball.getVx()));&#10;                } else {&#10;                    ball.setX(px + pw + ball.getRadius() + 0.1);&#10;                    ball.setVx(Math.abs(ball.getVx()));&#10;                }&#10;            } else {&#10;                // vertical impact&#10;                if (toPrevY &lt; 0) {&#10;                    ball.setY(py - ball.getRadius() - 0.1);&#10;                    ball.setVy(-Math.abs(ball.getVy()));&#10;                } else {&#10;                    ball.setY(py + ph + ball.getRadius() + 0.1);&#10;                    ball.setVy(Math.abs(ball.getVy()));&#10;                }&#10;            }&#10;        } else {&#10;            if (Math.abs(dx) &gt; Math.abs(dy)) {&#10;                if (dx &lt; 0) {&#10;                    ball.setX(closestX - ball.getRadius() - 0.1);&#10;                    ball.setVx(-Math.abs(ball.getVx()));&#10;                } else {&#10;                    ball.setX(closestX + ball.getRadius() + 0.1);&#10;                    ball.setVx(Math.abs(ball.getVx()));&#10;                }&#10;            } else {&#10;                if (dy &lt; 0) {&#10;                    ball.setY(closestY - ball.getRadius() - 0.1);&#10;                    ball.setVy(-Math.abs(ball.getVy()));&#10;                } else {&#10;                    ball.setY(closestY + ball.getRadius() + 0.1);&#10;                    ball.setVy(Math.abs(ball.getVy()));&#10;                }&#10;            }&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    // Liang-Barsky clipping to test segment vs AABB&#10;    private boolean segmentIntersectsAABB(double x1, double y1, double x2, double y2, double rx, double ry, double rw, double rh) {&#10;        double t0 = 0.0, t1 = 1.0;&#10;        double dx = x2 - x1;&#10;        double dy = y2 - y1;&#10;        double[] p = {-dx, dx, -dy, dy};&#10;        double[] q = {x1 - rx, rx + rw - x1, y1 - ry, ry + rh - y1};&#10;&#10;        for (int i = 0; i &lt; 4; i++) {&#10;            double pi = p[i];&#10;            double qi = q[i];&#10;            if (pi == 0) {&#10;                if (qi &lt; 0) return false;&#10;            } else {&#10;                double t = qi / pi;&#10;                if (pi &lt; 0) {&#10;                    if (t &gt; t1) return false;&#10;                    if (t &gt; t0) t0 = t;&#10;                } else {&#10;                    if (t &lt; t0) return false;&#10;                    if (t &lt; t1) t1 = t;&#10;                }&#10;            }&#10;        }&#10;        return t0 &lt;= t1;&#10;    }&#10;&#10;    private boolean circleIntersectsAABB(double cx, double cy, double r, double rx, double ry, double rw, double rh) {&#10;        double closestX = clamp(cx, rx, rx + rw);&#10;        double closestY = clamp(cy, ry, ry + rh);&#10;        double dx = cx - closestX;&#10;        double dy = cy - closestY;&#10;        return dx * dx + dy * dy &lt;= r * r;&#10;    }&#10;&#10;    private double clamp(double v, double a, double b) {&#10;        if (v &lt; a) return a;&#10;        if (v &gt; b) return b;&#10;        return v;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>